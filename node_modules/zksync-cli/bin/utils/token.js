import { BigNumber } from "ethers";
import { getAddress } from "ethers/lib/utils.js";
import { utils } from "zksync-ethers";
import { ETH_TOKEN } from "./constants.js";
const getTokenAddresses = async (tokenAddress, provider, l1Provider) => {
    let tokenL2Address;
    let tokenL1Address;
    if ((await provider.getCode(tokenAddress)) === "0x") {
        tokenL1Address = tokenAddress;
        const l2Address = await provider.l2TokenAddress(tokenAddress);
        if (!l1Provider || (await l1Provider.getCode(tokenAddress)) === "0x") {
            throw new Error("Token with specified address was not found");
        }
        if ((await provider.getCode(l2Address)) !== "0x") {
            tokenL2Address = l2Address;
        }
    }
    else {
        tokenL2Address = tokenAddress;
        const l1Address = await provider.l1TokenAddress(tokenAddress);
        // when token doesn't exist on L1 it resolves to Ether address
        if (l1Address !== ETH_TOKEN.l1Address) {
            tokenL1Address = l1Address;
        }
    }
    return {
        address: tokenL2Address ? getAddress(tokenL2Address) : undefined,
        l1Address: tokenL1Address ? getAddress(tokenL1Address) : undefined,
    };
};
export const getTokenInfo = async (tokenAddress, l2Provider, l1Provider) => {
    if (tokenAddress === ETH_TOKEN.address || tokenAddress === ETH_TOKEN.l1Address) {
        return ETH_TOKEN;
    }
    const { address, l1Address } = await getTokenAddresses(tokenAddress, l2Provider, l1Provider);
    if (!address && !l1Provider) {
        throw new Error("Token with specified address was not found");
    }
    const provider = address ? l2Provider : l1Provider;
    const tokenContractAddress = address || l1Address;
    const [symbol, name, decimals] = await Promise.all([
        provider.call({
            to: tokenContractAddress,
            data: utils.IERC20.encodeFunctionData("symbol()"),
        }),
        provider.call({
            to: tokenContractAddress,
            data: utils.IERC20.encodeFunctionData("name()"),
        }),
        provider.call({
            to: tokenContractAddress,
            data: utils.IERC20.encodeFunctionData("decimals()"),
        }),
    ]);
    return {
        address,
        symbol: utils.IERC20.decodeFunctionResult("symbol()", symbol).toString(),
        name: utils.IERC20.decodeFunctionResult("name()", name).toString(),
        decimals: parseInt(decimals, 16),
        l1Address,
    };
};
export const getBalance = async (tokenAddress, address, provider) => {
    if (tokenAddress === ETH_TOKEN.address || tokenAddress === ETH_TOKEN.l1Address) {
        return provider.getBalance(address);
    }
    const balanceAbi = "balanceOf(address)";
    return BigNumber.from(await provider.call({
        to: tokenAddress,
        data: utils.IERC20.encodeFunctionData(balanceAbi, [address]),
    }));
};
//# sourceMappingURL=token.js.map