import { ethers } from "ethers";
export const getInterfaceFromSignature = (method) => {
    return new ethers.utils.Interface(["function " + String(method)]);
};
export const getFragmentFromSignature = (method) => {
    const functionInterface = getInterfaceFromSignature(method);
    return functionInterface.fragments[0];
};
export const getInputsFromSignature = (method) => {
    return getFragmentFromSignature(method).inputs;
};
export const encodeData = (func, args) => {
    const functionInterface = getInterfaceFromSignature(func);
    return functionInterface.encodeFunctionData(func, args);
};
export const encodeParam = (param, arg) => {
    return ethers.utils.defaultAbiCoder.encode([param], [arg]);
};
export const decodeData = (types, bytecode) => {
    return ethers.utils.defaultAbiCoder.decode(types, bytecode);
};
export const getInputValues = (inputsString) => {
    return inputsString
        .split(",")
        .map((element) => element.trim())
        .filter((element) => !!element);
};
export const getMethodId = (method) => {
    const methodSignature = getFragmentFromSignature(method).format(ethers.utils.FormatTypes.sighash);
    return ethers.utils.id(methodSignature).substring(2, 10); // remove 0x and take first 4 bytes
};
export const getMethodsFromAbi = (abi, type) => {
    if (type === "read") {
        const readMethods = abi.filter((fragment) => fragment.type === "function" && (fragment.stateMutability === "view" || fragment.stateMutability === "pure"));
        const contractInterface = new ethers.utils.Interface(readMethods);
        return contractInterface.fragments;
    }
    else {
        const writeMethods = abi.filter((fragment) => fragment.type === "function" &&
            (fragment.stateMutability === "nonpayable" || fragment.stateMutability === "payable"));
        const contractInterface = new ethers.utils.Interface(writeMethods);
        return contractInterface.fragments;
    }
};
//# sourceMappingURL=formatters.js.map