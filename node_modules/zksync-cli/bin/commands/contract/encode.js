import chalk from "chalk";
import { ethers } from "ethers";
import inquirer from "inquirer";
import Program from "./command.js";
import { abiOption, argumentsOption, methodOption } from "./common/options.js";
import { encodeData, encodeParam, getFragmentFromSignature, getInputsFromSignature } from "./utils/formatters.js";
import { readAbiFromFile, askAbiMethod, formatMethodString } from "./utils/helpers.js";
import { logFullCommandFromOptions, optionNameToParam } from "../../utils/helpers.js";
import Logger from "../../utils/logger.js";
// ----------------
// prompts
// ----------------
const askMethod = async (contractAbi, options) => {
    if (options.method) {
        return;
    }
    const methodByAbi = await askAbiMethod({ abi: contractAbi });
    if (methodByAbi !== "manual") {
        const fullMethodName = methodByAbi.format(ethers.utils.FormatTypes.full);
        options.method = formatMethodString(fullMethodName);
        return;
    }
    const answers = await inquirer.prompt([
        {
            message: "Enter method to encode",
            name: optionNameToParam(methodOption.long),
            type: "input",
            validate: (input) => {
                try {
                    getFragmentFromSignature(input); // throws if invalid
                    return true;
                }
                catch {
                    return `Invalid method signature. Example: ${chalk.blueBright("balanceOf(address)")}`;
                }
            },
        },
    ], options);
    options.method = answers.method;
};
const askArguments = async (method, options) => {
    if (options.arguments) {
        return;
    }
    const inputs = getInputsFromSignature(method);
    if (!inputs.length) {
        options.arguments = [];
        return;
    }
    Logger.info(chalk.green("?") + chalk.bold(" Provide method arguments:"));
    const prompts = [];
    inputs.forEach((input, index) => {
        let name = chalk.gray(`[${index + 1}/${inputs.length}]`);
        if (input.name) {
            name += ` ${input.name}`;
            name += chalk.gray(` (${input.type})`);
        }
        else {
            name += ` ${input.type}`;
        }
        prompts.push({
            message: name,
            name: index.toString(),
            type: "input",
            validate: (value) => {
                try {
                    encodeParam(input, value); // throws if invalid
                    return true;
                }
                catch (error) {
                    return `${chalk.redBright("Failed to encode provided argument: " + (error instanceof Error ? error.message : error))}`;
                }
            },
        });
    });
    const answers = await inquirer.prompt(prompts);
    options.arguments = Object.values(answers);
};
// ----------------
// request handler
// ----------------
export const handler = async (options, context) => {
    try {
        let abi;
        if (options.abi) {
            abi = readAbiFromFile(options.abi);
            Logger.info(chalk.gray("Using provided ABI file"));
        }
        await askMethod(abi, options);
        await askArguments(options.method, options);
        const data = encodeData(options.method, options.arguments);
        Logger.info("");
        Logger.info(chalk.greenBright("âœ” Encoded data: ") + data);
        logFullCommandFromOptions(options, context, { emptyLine: true });
    }
    catch (error) {
        Logger.error("There was an error while performing encoding");
        Logger.error(error);
    }
};
Program.command("encode")
    .addOption(methodOption)
    .addOption(argumentsOption)
    .addOption(abiOption)
    .description("Get calldata (e.g. 0x1234) from contract method signature and arguments")
    .action(handler);
//# sourceMappingURL=encode.js.map